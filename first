# ppt_utils.py
# Description: Utility functions for manipulating PowerPoint presentations using python-pptx,
# including slide duplication and chart cloning.

import pandas as pd
import numpy as np
import io # For BytesIO
import copy
import random
import string
from itertools import islice

from pptx import Presentation # Should be imported by the calling app, but good for context
from pptx.chart.data import CategoryChartData
from pptx.enum.chart import XL_CHART_TYPE
from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.parts.slide import SlidePart
from pptx.opc.packuri import PackURI
from pptx.shapes.group import GroupShape
from pptx.opc.package import XmlPart
from pptx.oxml import parse_xml
from lxml import etree # python-pptx uses lxml
from io import BytesIO as IOBytes # Alias
from openpyxl import load_workbook


# Helper function to get relationships, with compatibility fix
def _object_rels(obj):
    """
    Retrieves relationships from a pptx object, handling potential
    API variations across python-pptx versions.
    """
    try:
        rels = obj.rels
        if not hasattr(rels, '_rels') and not hasattr(rels, 'items'): # Simple list or empty
             if not rels: return [] # Empty list
             # If it's a list of Relationship objects directly (older versions)
             if not isinstance(rels[0], str): return list(rels) # Return copy of list
        
        # For newer versions where rels might be dict-like or RelationalParts
        if hasattr(rels, 'items'): # Behaves like a dictionary
            return [v for k, v in rels.items()]
        elif hasattr(rels, '_rels'): # Access internal dict if present
            return [v for k,v in rels._rels.items()]
        else: # Fallback for list of rIds (less common for .rels directly)
             # This path is less likely for obj.rels but included for robustness if structure changes
             if rels and isinstance(rels[0], str):
                 return [obj.part.rels[rId] for rId in rels if rId in obj.part.rels] # Get Relationship objects
             return [] # Default empty if no known structure matches
    except AttributeError:
        return [] # Object doesn't have .rels or it's not as expected

# More robust slide adding mechanism (helper for duplicate_slide)
def _exp_add_slide(prs_slides_object, slide_layout_to_copy):
    """
    Function to handle slide creation in the Presentation.
    `prs_slides_object` is typically `prs.slides`.
    `slide_layout_to_copy` is the slide_layout object for the new slide.
    """
    def generate_slide_partname(slides_obj):
        """Return |PackURI| instance containing next available slide partname."""
        from pptx.opc.packuri import PackURI # Local import
        sldIdLst = slides_obj._element.get_or_add_sldIdLst()
        
        existing_rels_targets = []
        if hasattr(slides_obj.part, 'rels'):
             for rel in _object_rels(slides_obj.part):
                 if rel.reltype == RT.SLIDE:
                     existing_rels_targets.append(rel.target_partname)

        next_slide_num = 1
        while True:
            partname_str = "/ppt/slides/slide%d.xml" % next_slide_num
            if partname_str not in existing_rels_targets:
                if not slides_obj.package.has_part(partname_str):
                    break
            next_slide_num +=1
            if next_slide_num > len(sldIdLst) + 200: # Increased safety break
                 random_part = "".join(random.choice(string.ascii_letters) for i in range(3))
                 partname_str = "/ppt/slides/slide%s%d.xml" % (random_part, next_slide_num)
                 if partname_str not in existing_rels_targets and not slides_obj.package.has_part(partname_str):
                     break
                 # If still colliding, this indicates a deeper issue or extremely large presentation
                 if next_slide_num > len(sldIdLst) + 400:
                     raise OverflowError("Could not find a unique slide partname after many attempts.")
        return PackURI(partname_str)

    def add_slide_part_from_layout(slides_obj, new_slide_layout):
        from pptx.parts.slide import SlidePart # Local import
        partname = generate_slide_partname(slides_obj)
        slide_layout_part = new_slide_layout.part
        slide_part = SlidePart.new(partname, slides_obj.package, slide_layout_part)
        rId = slides_obj.part.relate_to(slide_part, RT.SLIDE)
        return rId, slide_part.slide

    rId, slide = add_slide_part_from_layout(prs_slides_object, slide_layout_to_copy)
    slide.shapes.clone_layout_placeholders(slide_layout_to_copy)
    prs_slides_object._sldIdLst.add_sldId(rId)
    return slide

# Shape removal helper
def remove_shape(shape):
    """Helper to remove a specific shape."""
    el = shape.element
    if el.getparent() is not None:
        el.getparent().remove(el)

# Chart cloning utilities
def chart_to_dataframe(graphical_frame) -> pd.DataFrame:
    """Helper to parse chart data to a DataFrame."""
    from openpyxl import load_workbook # Local import
    from io import BytesIO as IOBytes_local # Local alias

    try:
        blob = graphical_frame.chart.part.chart_workbook.xlsx_part.blob
        wb = load_workbook(IOBytes_local(blob), read_only=True)
        ws = wb.active
        data = ws.values
        
        first_row = next(data, None)
        if first_row is None: # Empty sheet
            return pd.DataFrame()
            
        cols = first_row[1:]
        data_list = list(data) # Convert iterator to list to check emptiness
        if not data_list: # No data rows after header
            return pd.DataFrame(columns=cols)

        idx = [r[0] for r in data_list]
        data_gen = (islice(r, 1, None) for r in data_list)
        df = pd.DataFrame(data_gen, index=idx, columns=cols)
    except Exception as e:
        # print(f"Warning: Error converting chart to DataFrame: {e}. Returning empty DataFrame.")
        df = pd.DataFrame() # Return empty df on error
    return df

def dataframe_to_chart_data(df: pd.DataFrame):
    """Transforms a DataFrame to a CategoryChartData for PPT compilation."""
    from pptx.chart.data import CategoryChartData # Local import
    import numpy as np # Local import

    chart_data_obj = CategoryChartData()
    if df.empty or df.index.empty:
        chart_data_obj.categories = ["Default Category"] # Placeholder
        chart_data_obj.add_series("Default Series", (0,)) # Add tuple for values
        return chart_data_obj

    chart_data_obj.categories = df.index.astype(str).to_list()
    edge_cases = 0
    for c in df.columns:
        series_data = df[c].copy()
        series_data.replace([np.inf, -np.inf], np.nan, inplace=True)
        # Ensure values are appropriate for pptx (numeric or None)
        fixed_series_values = []
        for x in series_data:
            if pd.isna(x):
                fixed_series_values.append(None)
            elif isinstance(x, (int, float)):
                fixed_series_values.append(x)
            else: # Try to convert, else None
                try:
                    fixed_series_values.append(float(x))
                except (ValueError, TypeError):
                    fixed_series_values.append(None)
                    edge_cases +=1
        
        chart_data_obj.add_series(str(c), tuple(fixed_series_values)) # Use tuple for values
    
    if edge_cases > 0:
        import warnings
        warnings.warn("Series data containing non-numeric or INF values: converted to empty/None for PPTX chart.")
    return chart_data_obj

def clone_chart(source_graphic_frame, dest_shapes_collection):
    """
    Clones a chart with related styling.
    Returns the new chart's GraphicFrame object.
    """
    import copy # Local import
    from lxml import etree # Local import
    from pptx.oxml import parse_xml # Local import

    source_chart = source_graphic_frame.chart
    
    try:
        df = chart_to_dataframe(source_graphic_frame)
        chart_data_for_new_chart = dataframe_to_chart_data(df)
    except Exception as e:
        # print(f"Warning: Could not extract/process data from source chart '{source_graphic_frame.name}': {e}. Creating new chart with placeholder data.")
        chart_data_for_new_chart = CategoryChartData()
        chart_data_for_new_chart.categories = ["Category 1"]
        chart_data_for_new_chart.add_series("Series 1", (0,))

    new_chart_graphic_frame = dest_shapes_collection.add_chart(
        source_chart.chart_type,
        source_graphic_frame.left,
        source_graphic_frame.top,
        source_graphic_frame.width,
        source_graphic_frame.height,
        chart_data_for_new_chart,
    )

    try:
        id_attribute = "{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id"
        
        # Source chart part
        old_chart_graphic_data_el = source_graphic_frame.element.xpath(".//a:graphicData/c:chart", namespaces={'a': 'http://schemas.openxmlformats.org/drawingml/2006/main', 'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
        if not old_chart_graphic_data_el: raise ValueError("Source chart XML structure not found (graphicData/chart).")
        old_chart_rId = old_chart_graphic_data_el[0].get(id_attribute)
        if not old_chart_rId or old_chart_rId not in source_graphic_frame.part.rels: raise ValueError(f"Source chart rId '{old_chart_rId}' not found in relationships.")
        old_chart_part = source_graphic_frame.part.rels[old_chart_rId].target_part

        # New chart part
        new_chart_graphic_data_el = new_chart_graphic_frame.element.xpath(".//a:graphicData/c:chart", namespaces={'a': 'http://schemas.openxmlformats.org/drawingml/2006/main', 'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
        if not new_chart_graphic_data_el: raise ValueError("New chart XML structure not found (graphicData/chart).")
        new_chart_rId = new_chart_graphic_data_el[0].get(id_attribute)
        if not new_chart_rId or new_chart_rId not in new_chart_graphic_frame.part.rels: raise ValueError(f"New chart rId '{new_chart_rId}' not found in relationships.")
        new_chart_part_obj = new_chart_graphic_frame.part.rels[new_chart_rId].target_part

        # Clone the main chart XML content (c:chartSpace)
        cloned_chart_element_xml = copy.deepcopy(old_chart_part.element)

        # Preserve the new chart's externalData rId (points to its own Excel package)
        new_chart_external_data_el_list = new_chart_part_obj.element.xpath(".//c:externalData", namespaces={'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
        if new_chart_external_data_el_list:
            new_external_data_rId = new_chart_external_data_el_list[0].get(id_attribute)
            cloned_external_data_el_list = cloned_chart_element_xml.xpath(".//c:externalData", namespaces={'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
            if cloned_external_data_el_list:
                cloned_external_data_el_list[0].set(id_attribute, new_external_data_rId)

        # Ensure autoUpdate is set
        auto_update_list = cloned_chart_element_xml.xpath(".//c:autoUpdate", namespaces={'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
        if auto_update_list:
             auto_update_list[0].set("val", "1")
        else:
            # Simplified: Add autoUpdate if not present. Proper placement might be needed.
            chart_space_root = cloned_chart_element_xml
            plot_area_list = chart_space_root.xpath("c:plotArea", namespaces={'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart'})
            if plot_area_list:
                auto_update_el = etree.Element("{http://schemas.openxmlformats.org/drawingml/2006/chart}autoUpdate")
                auto_update_el.set("val", "1")
                plot_area_list[0].addprevious(auto_update_el) # Insert before plotArea
            # else: consider appending to chart_space_root or other suitable location

        new_chart_part_obj.element = cloned_chart_element_xml

        # TODO: Implement robust cloning of ColorsPart and StylePart as in your original example
        # This is complex and involves creating new parts and relationships.
        # print("Warning: Detailed chart style/color part cloning (ColorsPart, StylePart) is complex and omitted in this simplified version.")

    except Exception as e:
        # print(f"Warning: Could not fully clone chart style for '{source_graphic_frame.name}': {e}. Basic chart added.")
        pass # Allow basic chart to be returned

    return new_chart_graphic_frame

# Shape copying helper
def copy_shapes(source_shapes_collection, dest_slide):
    """Copies shapes from source_shapes_collection to dest_slide.shapes."""
    from pptx.shapes.group import GroupShape # Local import
    import copy # Local import

    for source_shape in source_shapes_collection:
        new_shape_on_dest = None
        try:
            if isinstance(source_shape, GroupShape):
                # Basic group copy - for full fidelity, this needs more XML work like in your example
                new_group = dest_slide.shapes.add_group_shape()
                # Attempt to copy basic properties
                if hasattr(source_shape, 'name'): new_group.name = source_shape.name
                new_group.left, new_group.top, new_group.width, new_group.height = \
                    source_shape.left, source_shape.top, source_shape.width, source_shape.height
                if hasattr(source_shape, 'rotation'): new_group.rotation = source_shape.rotation
                
                # Recursive copy for shapes within the group
                copy_shapes(source_shape.shapes, new_group) # Pass new_group as the destination slide/group
                new_shape_on_dest = new_group

            elif hasattr(source_shape, "image"):
                from io import BytesIO as IOBytes_local # Local alias
                content = IOBytes_local(source_shape.image.blob)
                new_pic = dest_slide.shapes.add_picture(
                    content, source_shape.left, source_shape.top, source_shape.width, source_shape.height
                )
                if hasattr(source_shape, 'name'): new_pic.name = source_shape.name
                # Copy crop properties if they exist
                for prop in ['crop_left', 'crop_right', 'crop_top', 'crop_bottom']:
                    if hasattr(source_shape, prop): setattr(new_pic, prop, getattr(source_shape, prop))
                new_shape_on_dest = new_pic

            elif hasattr(source_shape, "has_chart") and source_shape.has_chart:
                new_shape_on_dest = clone_chart(source_shape, dest_slide.shapes)
                if new_shape_on_dest and hasattr(source_shape, 'name') and source_shape.name:
                    try:
                        new_shape_on_dest.name = source_shape.name
                    except AttributeError: pass # Some cloned shapes might not allow direct name set initially

            else: # Other generic shapes
                newel = copy.deepcopy(source_shape.element)
                dest_slide.shapes._spTree.insert_element_before(newel, "p:extLst") # Add to shape tree
                new_shape_on_dest = dest_slide.shapes[-1]
                if new_shape_on_dest and hasattr(source_shape, 'name') and source_shape.name:
                    try:
                        new_shape_on_dest.name = source_shape.name
                    except AttributeError: pass
        except Exception as e:
            # print(f"Warning: Could not copy shape '{getattr(source_shape, 'name', 'Unnamed')}': {e}")
            pass # Continue with other shapes

# Main slide duplication function
def duplicate_slide(prs: Presentation, slide_to_copy_index: int):
    """
    Duplicates the slide at `slide_to_copy_index` in `prs` and adds it to the end.
    Returns the new `Slide` object.
    """
    if not (0 <= slide_to_copy_index < len(prs.slides)):
        raise ValueError(f"Slide index {slide_to_copy_index} is out of bounds for presentation with {len(prs.slides)} slides.")

    source_slide = prs.slides[slide_to_copy_index]
    
    # Create a new slide using the same layout as the source
    dest_slide = _exp_add_slide(prs.slides, source_slide.slide_layout)
    
    # Remove default placeholders that were cloned from the layout onto the new slide
    # Iterating backwards for safe deletion if shapes collection changes
    if hasattr(dest_slide.shapes, '_spTree'): # Check if shapes are present
        for i in range(len(dest_slide.shapes) - 1, -1, -1):
            try:
                remove_shape(dest_slide.shapes[i])
            except Exception as e:
                # print(f"Note: Could not remove a default shape during slide duplication prep: {e}")
                pass # Continue if a shape can't be removed
        
    # Copy shapes from source slide to destination slide
    copy_shapes(source_slide.shapes, dest_slide)
    
    # Copy notes slide content
    if source_slide.has_notes_slide:
        txt = source_slide.notes_slide.notes_text_frame.text
        if not dest_slide.has_notes_slide:
            # If the new slide (from layout) didn't get a notes part automatically, create one.
            # This is less common if the layout itself implies a notes slide.
            try:
                notes_slide_part = dest_slide.part.package.create_notes_slide_part(dest_slide.part)
                dest_slide.part.relate_to(notes_slide_part, RT.NOTES_SLIDE)
            except Exception as e:
                # print(f"Note: Could not create notes slide for duplicated slide: {e}")
                pass # Continue without notes if creation fails
        
        if dest_slide.has_notes_slide: # Check again after potential creation
            dest_slide.notes_slide.notes_text_frame.text = txt

    # Relationship copying for general slide items (e.g. hyperlinks)
    # This is a simplified version. Robust rel copying is complex.
    # Chart-specific relationships should ideally be handled within clone_chart.
    try:
        if hasattr(source_slide.part, 'rels'):
            for rel in _object_rels(source_slide.part):
                if rel.is_external and rel.reltype == RT.HYPERLINK:
                    dest_slide.part.rels.get_or_add_ext_rel(RT.HYPERLINK, rel.target_ref)
                # Internal relationships (e.g., to other parts like media) are much harder
                # as those target parts would also need to be duplicated and re-linked.
                # This is often handled at the shape-copying level for specific types like images.
    except Exception as e:
        # print(f"Note: Error during general relationship copying for slide: {e}")
        pass

    return dest_slide
